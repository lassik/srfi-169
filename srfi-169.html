<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI 169: Underscores in Numbers</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>
  <body>
    <h1>Title</h1>
    <p>SRFI 169: Underscores in Numbers</p>
    <h1>Author</h1>
    <p>Lassi Kortela</p>
    <h1>Status</h1>

    <p>This SRFI is currently in <em>draft</em> status.  Here is
      <a href="https://srfi.schemers.org/srfi-process.html">an
        explanation</a> of each status that a SRFI can hold.  To
      provide input on this SRFI, please send email to
      <code><a href="mailto:srfi+minus+169+at+srfi+dotschemers+dot+org">srfi-169@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.
      To subscribe to the list, follow
      <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these
        instructions</a>.  You can access previous messages via the
      mailing list <a href="https://srfi-email.schemers.org/srfi-169">archive</a>.</p>

    <ul>
      <li>Received: 2019/4/16</li>
      <li>60-day deadline: 2019/6/17</li>
      <li>Draft #1 published: 2019/4/18</li>
    </ul>

    <h1>Abstract</h1>

    <p>Many people find that large numbers are easier to read when the
      digits are broken into small groups.  For example, the number
      <code>1582439</code> might be easier to read if written as <code>1
      582 439</code>.  This applies to source code as it does to other
      writing.  We propose an extension of Scheme syntax to allow the
      underscore as a digit separator in numerical constants.</p>

    <h1>Rationale</h1>

    <h2>How many digits per group</h2>

    <p>Western cultures tend to divide digits into groups of three.
      This convention is not universal.  For example, in India people
      write numbers like <code>3 14 15 926</code> (read <em>three crore
      fourteen lakh fifteen thousand nine hundred and twenty-six</em> in
      Indian English).</p>

    <p>For simplicity and universality, we propose that digit groups
      of all sizes may be mixed freely when writing a number.  It is
      permissible to have just one digit in a group, and groups in a
      number don’t need to be ordered by increasing or decreasing
      digit count.</p>

    <h2>What separator character to use</h2>

    <p>Human cultures and programming languages differ in what separator to use between groups.</p>

    <ul>
      <li><p>The examples in this document so far have used a space.
        This is familiar to humans but not a good fit for most
        programming languages since whitespace has a prominent role as
        token separator.  Scheme is no exception here.</p></li>

      <li><p>The next natural alternative is to use a comma or a
        period.  This is likely to cause confusion in an international
        community since countries that use a comma as the decimal
        separator are as numerous as those that use a period.  More
        trouble comes from Scheme using the comma to splice things into
        a quasiquoted list: e.g.  <code>`(1,2)</code> evaluates to
        <code>(1 2)</code>.  Allowing commas in numbers would change
        splicing behavior in a confusing way.</p></li>

      <li><p>C++ uses an apostrophe which is somewhat exotic and may
        call to mind units of measure, e.g. feet and inches.  Scheme
        also uses the apostrophe for quotation: e.g. <code>'(1'2)</code>
        evaluates to <code>(1 (quote 2))</code>.  Allowing apostrophes
        in numbers would change the meaning of this syntax.</p></li>

      <li><p>The most popular digit group separator among programming
        languages is the underscore.  It is in the standard syntax of
        Ada, C#, Clojure, Eiffel, Frink, Java, Julia, Kotlin, OCaml,
        Perl, Python, Ruby, Rust and Swift.  It is also being added to
        JavaScript and is a common syntax extension in implementations
        of Standard ML.  The Common Lisp standard permits it under the
        umbrella of <em>potential numbers</em> but we are not aware of
        implementations that use the opportunity.  Of Scheme
        implementations, Gauche can read numbers with underscores when
        they have a radix or exactness prefix.</p></li>
    </ul>

    <p>In light of the above, we consider the underscore to be the
      clear winner.  It is the most widely compatible and least
      ambiguous choice, in both human and machine terms.</p>

    <h2>Potential ambiguity between numbers and identifiers</h2>

    <p>Languages in the Lisp family traditionally allow a larger set
      of characters in identifiers than do most other languages. For
      example, the tokens <code>1+</code> and <code>3*/!</code> parse
      as symbols in Common Lisp. Scheme is slightly more restrictive:
      none of R<sup>4</sup>RS, R<sup>5</sup>RS, R<sup>6</sup>RS and
      R<sup>7</sup>RS recognize identifiers that begin with a decimal
      digit. Some implementations are more relaxed with identifiers.
      For example, MIT Scheme comes with <code>1+</code> and
      <code>-1+</code> procedures to increment and decrement numbers.
      Several implementations presently parse tokens consisting entirely
      of digits and underscores as symbols.</p>

    <p>Countless languages outside the Lisp family have a convention
      of using underscores as word separators in multi-word
      identifiers. Following that convention, Scheme’s
      <code>open-input-file</code> would be spelled
      <code>open_input_file</code> instead. In these languages it’s
      common to use a leading underscore to mark private (as opposed
      to public or exported) identifiers. This leads to potential
      ambiguity with identifiers such as <code>_123</code> that start
      with an underscore and contain only underscores and digits. Such
      tokens often parse as identifiers. If we made them parse as
      numbers in Scheme it could confuse programmers and spell trouble
      for code generators that translate Scheme symbols to other
      languages.</p>

    <p>Trailing underscores at the end of a number might cause trouble
        if another syntax extension is made to support units of
        measure and the name of a unit is allowed to begin with a
        digit. In the worst case it could be ambiguous where the
        numerical quantity ends and the unit's name begins.</p>

    <p>Scheme supports a rich numeric tower of integers, ratios, real
      and complex numbers. These come in exact and inexact varieties.
      For real numbers, we have decimal-point and exponent notation.
      The Kawa implementation of Scheme adds quaternions and units of
      measure to the mix. Common Lisp’s <em>potential numbers</em>
      offer a glimpse of how far numerical syntax can go. These
      intricate extensions, some of which we cannot even anticipate
      yet, make it even trickier for us to specify a digit separation
      scheme devoid of ambiguity.</p>

    <p>We attempt to solve these problems with a conservative rule
      that allows underscores only <em>between</em> digits.  After
      considering everything in the above paragraphs, we did not manage
      to come up with any concrete examples of present or future tasks
      that would be impeded by this restricted version of the syntax
      extension.</p>

    <p>As an extra measure we also forbid more than one consecutive
    underscore. We could not think of any particular situations where
    repeated underscores cause problems but decided to avoid them
    anyway. There are enough similar gotchas that caution seems the
    wise choice.</p>

    <h2>Printing numbers with underscores</h2>

    <p>
      This SRFI does not specify anything about inserting underscores
      into numbers at print time. Printing with underscores would be
      as useful as reading is, especially when using a Scheme
      <em>read-eval-print loop</em> as a calculator. However, there is
      no consensus on how to best extend the Scheme printer. Major
      work is underway but it will not stabilize in time for the
      publication of this SRFI.
    </p>
    <p>
      Apart from printer extension concerns the cultural conventions
      of where to place digit separators are also varied and complex.
      When reading numbers we can leave the decision to writers and
      simply accept a wide range of possibilities. When printing we
      would have to make those decisions, or else map out what printer
      options are needed and design good defaults for them.
    </p>
    <p>
      For these reasons, decisions about printing are deferred to
      implementations and to future SRFIs.
    </p>

    <h1>Specification</h1>

    <p>We stipulate that conforming implementations must <em>allow one
      underscore between any two digits, in any part of a
      number</em>.</p>

    <p>The rule <em>includes</em>:</p>
    <ul>
      <li><p>Underscores in numbers of any radix (binary, octal,
        decimal, hexadecimal).</p></li>

      <li><p>Underscores between letters that represent digits in a
        radix higher than 10 (hexadecimal in particular).</p></li>

      <li><p>Underscores in the numerator and/or denominator of a
        ratio.</p></li>

      <li><p>Underscores in the integer, fractional and/or exponent
        part of a real number.</p></li>

      <li><p>Underscores in the real and/or imaginary part of a
        complex number.</p></li>

      <li><p>Underscores in any dimension of a hypercomplex number
        (for implementations with syntax for such numbers).</p></li>

      <li><p>Underscores in both exact and inexact numbers.</p></li>

      <li><p>Underscores in the quantity part of a number with a unit
        of measure (for implementations with syntax for units of
        measure).</p></li>

      <li><p>Underscores between leading zeros (but not before the
        first zero).</p></li>
    </ul>

    <p>The rule <em>excludes</em>:</p>

    <ul>
      <li><p>Leading underscores.</li>

      <li><p>Underscores between sign and magnitude.</p></li>

      <li><p>Underscores between a radix or exactness prefix, and the
        digits.</p></li>

      <li><p>Trailing underscores.</p></li>

      <li><p>Two or more consecutive underscores.</p></li>
    </ul>

    <p>Conforming implementations <em>may</em> be more lenient in what
      they allow (to maintain compatibility with existing code).  In
      this document, numbers written according to the above rule are
      called <em>conforming</em>.  Other numbers (which may or may not
      be valid depending on the implementation) are called
      <em>non-conforming</em>.</p>

    <h1>Examples</h1>

    <h2>Integers</h2>

    <pre><code>0123             ; conforming
0_1_2_3          ; conforming
0_123            ; conforming
01_23            ; conforming
012_3            ; conforming
+0123            ; conforming
+0_123           ; conforming
-0123            ; conforming
-0_123           ; conforming

_0123            ; non-conforming
0123_            ; non-conforming
0123__           ; non-conforming
01__23           ; non-conforming
0_1__2___3       ; non-conforming
+_0123           ; non-conforming
+0123_           ; non-conforming
-_0123           ; non-conforming
-0123_           ; non-conforming</code></pre>

    <h2>Rational numbers</h2>
    <pre><code>1_2_3/4_5_6_7    ; conforming
12_34/5_678      ; conforming

1_2_3/_4_5_6_7   ; non-conforming
_12_34/5_678     ; non-conforming</code></pre>

    <h2>Real numbers</h2>
    <pre><code>0_1_23.4_5_6     ; conforming
1_2_3.5e6        ; conforming
1_2e1_2          ; conforming

_0123.456        ; non-conforming
0123_.456        ; non-conforming
0123._456        ; non-conforming
0123.456_        ; non-conforming
123_.5e6         ; non-conforming
123._5e6         ; non-conforming
123.5_e6         ; non-conforming
123.5e_6         ; non-conforming
123.5e6_         ; non-conforming
12_e12           ; non-conforming
12e_12           ; non-conforming
12e12_           ; non-conforming</code></pre>

    <h2>Complex numbers</h2>

    <pre><code>-12_3.0_00_00-12_34.56_78i   ; conforming
-12_3.0_00_00@-12_34.56_78   ; conforming

-12_3.0_00_00-12_34.56_78_i   ; non-conforming
-12_3.0_00_00-12_34.56_78i_   ; non-conforming
-12_3.0_00_00_@-12_34.56_78   ; non-conforming
-12_3.0_00_00@_-12_34.56_78   ; non-conforming</code></pre>

    <h2>Hypercomplex numbers</h2>

    <p>Kawa supports quaternions using the following syntax:</p>
    <pre><code>1+2i-3j+4k</code></pre>

    <p>By applying the rule a syntax like that can be extended as
      follows:</p>

    <pre><code>1_0+2_0i-3_0j+4_0k   ; conforming

1_0_+2_0i-3_0j+4_0k  ; non-conforming
1_0+2_0_i-3_0j+4_0k  ; non-conforming
1_0+2_0i-3_0j_+4_0k  ; non-conforming
1_0+2_0i-3_0j+4_0k_  ; non-conforming</code></pre>

    <h2>Units of measure</h2>

    <p>Kawa supports units of measure using the following syntax:</p>

    <pre><code>123456cm^2</code></pre>

    <p>By applying the rule a syntax like that can be extended as
      follows:</p>

    <pre><code>123_456cm^2          ; conforming

123_456_cm^2         ; non-conforming
123_456.78_cm^2      ; non-conforming</code></pre>

    <h2>Numbers with radix or exactness prefixes</h2>
    <pre><code>#b10_10_10           ; conforming
#o23_45_67           ; conforming
#d45_67_89           ; conforming
#xAB_CD_EF           ; conforming
#x-2_0               ; conforming
#o+2_345_6           ; conforming

#x-_2                ; non-conforming
_#x-_2               ; non-conforming
#d_45_67_89          ; non-conforming
#e_45/67_89          ; non-conforming
#i#o_1234            ; non-conforming
#i_#o_1234           ; non-conforming
#e#x1234_            ; non-conforming</code></pre>

    <h1>Implementation</h1>

    <p>This reference implementation is a portable R<sup>7</sup>RS
      library. It exports one procedure <code>(read-number)</code>
      which takes no arguments. The procedure reads one Scheme number
      from <code>current-input-port</code> with support for optional
      underscores as specified in this SRFI. It signals an error if
      underscores are used in a non-conforming way according to the
      rule stipulated in this SRFI, or if the number syntax (sans
      underscores) does not conform to the R<sup>7</sup>RS
      specification.</p>

    <p>This reader supports most of the R<sup>7</sup>RS numeric tower
      with the notable exception of complex numbers. The values of
      inexact numbers may diverge from the values produced by the
      native reader of a Scheme implementation if it uses different
      formulas for numeric conversion.</p>

    <p>The code has been tested against the examples in this SRFI.
      Correct results were obtained with Chibi-Scheme, Gauche and
      Kawa. The test harness is available on request.</p>

    <pre>
;;; Conditional reading utility

(define (read-char-limit? chars limit)
  (let ((ch (peek-char)))
    (let loop ((i 0))
      (cond ((>= i limit) #f)
            ((eqv? ch (string-ref chars i)) (read-char) i)
            (else (loop (+ i 1)))))))

(define (read-char? chars)
  (read-char-limit? chars (string-length chars)))

;;; Digit span reader

;; All the underscore considerations are in the following procedure,
;; which reads a span of one or more digits. It returns two values:
;; the exact nonnegative integer value represented by the digits, and
;; the count of digits. If there are no digits, those are #f and 0.

(define (read-and-count-digits? radix)
  (let ((radix (or radix 10))
        (lodigits "0123456789abcdef")
        (updigits "0123456789ABCDEF"))
    (let loop ((was-digit? #f) (count 0) (value #f))
      (if (read-char? "_")
          (cond (was-digit? (loop #f count value))
                (value (error "More than one consecutive underscore"))
                (else (error "Underscore before digits")))
          (let ((digit (or (read-char-limit? lodigits radix)
                           (read-char-limit? updigits radix))))
            (cond (digit
                   (loop #t (+ count 1) (+ digit (* radix (or value 0)))))
                  ((and value (not was-digit?))
                   (error "Underscore after digits"))
                  (else (values value count))))))))

(define (read-digits? radix)
  (let-values (((value _) (read-and-count-digits? radix)))
    value))

(define (read-fractional-part)
  (let-values (((value count) (read-and-count-digits? 10)))
    (inexact (/ (or value 0) (expt 10 count)))))

;;; Scheme number reader

;; The rest of the code covers a large subset of R7RS number syntax.
;; Complex numbers are regrettably not included. I am not a math
;; wizard and did not work on any RnRS report so do not trust this
;; code as an authority on how to do numbers right.

(define (read-prefix? old chars values error-msg)
  (let ((new (read-char? chars)))
    (cond ((and old new) (error error-msg))
          (new (vector-ref values new))
          (else #f))))

(define (read-radix-prefix? old)
  (read-prefix? old "bodx" #(2 8 10 16) "More than one radix prefix"))

(define (read-exactness-prefix? old)
  (read-prefix? old "ei" #(e i) "More than one exactness prefix"))

(define (read-number-prefixes)
  (let loop ((radix #f) (exactness #f))
    (if (not (read-char? "#"))
        (values radix exactness)
        (let ((new-radix (read-radix-prefix? radix)))
          (if new-radix
              (loop new-radix exactness)
              (let ((new-exactness (read-exactness-prefix? exactness)))
                (if new-exactness
                    (loop radix new-exactness)
                    (error "Unknown # prefix"))))))))

(define (make-decimal integer-part fractional-part exponent-part)
  (* (+ integer-part fractional-part) (expt 10 (or exponent-part 0))))

(define (read-exponent? radix)
  (cond ((not (read-char? "e")) #f)
        (radix (error "Exponent not allowed with radix prefix"))
        (else (or (read-digits? 10) (error "No exponent")))))

(define (read-decimal-part radix integer-part)
  (when radix (error "Decimal point not allowed with radix prefix"))
  (let ((fractional-part (read-fractional-part)))
    (make-decimal integer-part fractional-part (read-exponent? radix))))

(define (read-ureal? radix)
  (if (read-char? ".")
      (read-decimal-part radix 0)
      (let ((first-digits (read-digits? radix)))
        (cond ((not first-digits) #f)
              ((read-char? ".") (read-decimal-part radix first-digits))
              ((read-char? "/")
               (let ((other-digits (read-digits? radix)))
                 (if other-digits
                     (/ first-digits other-digits)
                     (error "Missing denominator in ratio"))))
              (else
               (make-decimal first-digits 0 (read-exponent? radix)))))))

(define (read-number)
  (let-values (((radix exactness) (read-number-prefixes)))
    (let* ((sign (if (read-char? "-") -1 (begin (read-char? "+") 1)))
           (magnitude (read-ureal? radix)))
      (unless (eof-object? (peek-char)) (error "Junk after number"))
      (cond ((and (not magnitude) (or radix exactness))
             (error "Missing numeric value after # prefix"))
            ((not magnitude)
             (error "Missing numeric value"))
            (else (let ((value (* sign magnitude)))
                    (case exactness
                      ((e) (exact value))
                      ((i) (inexact value))
                      (else value))))))))
</pre>

    <p>The R<sup>7</sup>RS library definition is as follows.</p>
    <pre>
(define-library (read-number)
  (import (scheme base) (scheme inexact) (scheme read) (scheme write))
  (include "read-number.scm")
  (export read-number))
    </pre>

    <h1>Acknowledgements</h1>

    <p>
      This SRFI is the result of an impromptu design session on
      the <code>srfi-discuss</code> mailing list over the weekend
      between April 12th and April 15th.
    </p>
    <p>
      Lassi Kortela suggested the idea, wrote this document and
      produced the reference implementation. However the design is
      entirely a group effort.
    </p>
    <p>
      John Cowan provided invaluable expertise on human and computer
      languages. He cautioned against requiring a fixed number of
      digits per group and provided the Indian English example. John
      found the extensive list of programming languages already using
      underscores. John and Lassi cautioned against the ambiguity of
      using commas as delimiters.
    </p>
    <p>
      Per Bothner introduced Kawa's extended number syntax and noted
      Common Lisp's <em>potential numbers</em> as prior art. Per and
      John made sure the underscore syntax works when units of measure
      are supported, considering prior art from Kawa's syntax and the
      JavaScript community. Per explained Kawa's syntax for
      quaternions which led to hypercomplex numbers being supported.
    </p>
    <p>
      Shiro Kawai explained the approach of Gauche which can already
      skip underscores when reading <code>#</code>-prefixed numbers.
    </p>
    <p>
      Peter Bex cautioned against over-extending Scheme's already
      intricate number syntax and potentially breaking
      backward-compatibility for some programs. John and Lassi
      advocated forbidding leading, trailing and repeated underscores
      as a reasonable precaution. Arthur Gleckler suggested a
      dedicated <code>#_</code> prefix and a user interface feature
      for text editors as two failsafe alternatives.
    </p>
    <p>
      Shiro, Peter and John reminded us that symbols starting with
      digits are forbidden in Scheme standards since R<sup>4</sup>RS. But Jim
      Rees, Arthur and John brought up <em>peculiar identifiers</em>
      which let implementations break that rule.
    </p>
    <p>
      Hugo Hörnquist had the idea of using
      Scheme's <code>display</code> procedure to print numbers with
      underscores, reserving <code>write</code> for portable syntax.
      John advised to postpone any decisions about printing, pointing
      to Alex Shinn's SRFI 159 and SRFI 166 as potential solutions
      with a view to the upcoming large edition of the R<sup>7</sup>RS
      standard.
    </p>

    <h1>Copyright</h1>

    <p>Copyright © Lassi Kortela (2019).</p>

    <p>Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the “Software”), to deal in the Software without
      restriction, including without limitation the rights to use, copy,
      modify, merge, publish, distribute, sublicense, and/or sell copies
      of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:</p>

    <p>The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the
      Software.</p>

    <p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.</p>
  </body>
</html>
